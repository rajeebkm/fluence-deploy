// GENERATED BY ISLE. DO NOT EDIT!
//
// Generated automatically from the instruction-selection DSL code in:
// - src/prelude.isle
// - src/prelude_opt.isle
// - src/opts/algebraic.isle
// - src/opts/cprop.isle
// - /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle

use super::*; // Pulls in all external types.
use std::marker::PhantomData;

/// Context during lowering: an implementation of this trait
/// must be provided with all external constructors and extractors.
/// A mutable borrow is passed along through all lowering logic.
pub trait Context {
    fn unit(&mut self) -> Unit;
    fn value_type(&mut self, arg0: Value) -> Type;
    fn u32_add(&mut self, arg0: u32, arg1: u32) -> u32;
    fn s32_add_fallible(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_nonnegative(&mut self, arg0: u32) -> Option<u32>;
    fn offset32(&mut self, arg0: Offset32) -> u32;
    fn u32_lteq(&mut self, arg0: u32, arg1: u32) -> Option<Unit>;
    fn u8_lteq(&mut self, arg0: u8, arg1: u8) -> Option<Unit>;
    fn u8_lt(&mut self, arg0: u8, arg1: u8) -> Option<Unit>;
    fn simm32(&mut self, arg0: Imm64) -> Option<u32>;
    fn uimm8(&mut self, arg0: Imm64) -> Option<u8>;
    fn u8_and(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_as_u32(&mut self, arg0: u8) -> u32;
    fn u8_as_u64(&mut self, arg0: u8) -> u64;
    fn u16_as_u64(&mut self, arg0: u16) -> u64;
    fn u32_as_u64(&mut self, arg0: u32) -> u64;
    fn i64_as_u64(&mut self, arg0: i64) -> u64;
    fn u64_add(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_sub(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_mul(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_sdiv(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_udiv(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_and(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_or(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_xor(&mut self, arg0: u64, arg1: u64) -> u64;
    fn imm64_shl(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn imm64_ushr(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn imm64_sshr(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn u64_not(&mut self, arg0: u64) -> u64;
    fn u64_eq(&mut self, arg0: u64, arg1: u64) -> bool;
    fn i64_sextend_imm64(&mut self, arg0: Type, arg1: Imm64) -> i64;
    fn u64_uextend_imm64(&mut self, arg0: Type, arg1: Imm64) -> u64;
    fn imm64_icmp(&mut self, arg0: Type, arg1: &IntCC, arg2: Imm64, arg3: Imm64) -> Imm64;
    fn u64_is_zero(&mut self, arg0: u64) -> bool;
    fn u64_is_odd(&mut self, arg0: u64) -> bool;
    fn ty_bits(&mut self, arg0: Type) -> u8;
    fn ty_bits_u16(&mut self, arg0: Type) -> u16;
    fn ty_bits_u64(&mut self, arg0: Type) -> u64;
    fn ty_mask(&mut self, arg0: Type) -> u64;
    fn ty_bytes(&mut self, arg0: Type) -> u16;
    fn lane_type(&mut self, arg0: Type) -> Type;
    fn mem_flags_trusted(&mut self) -> MemFlags;
    fn intcc_reverse(&mut self, arg0: &IntCC) -> IntCC;
    fn intcc_inverse(&mut self, arg0: &IntCC) -> IntCC;
    fn floatcc_reverse(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_inverse(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_unordered(&mut self, arg0: &FloatCC) -> bool;
    fn fits_in_16(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn lane_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_scalar_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32_or_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_8_or_16(&mut self, arg0: Type) -> Option<Type>;
    fn int_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_float_or_vec(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_not_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_ctor(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128_int(&mut self, arg0: Type) -> Option<Type>;
    fn not_vec32x2(&mut self, arg0: Type) -> Option<Type>;
    fn not_i64x2(&mut self, arg0: Type) -> Option<()>;
    fn u8_from_uimm8(&mut self, arg0: Uimm8) -> u8;
    fn u64_from_bool(&mut self, arg0: bool) -> u64;
    fn u64_from_imm64(&mut self, arg0: Imm64) -> u64;
    fn nonzero_u64_from_imm64(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64_power_of_two(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64(&mut self, arg0: u64) -> Imm64;
    fn imm64_masked(&mut self, arg0: Type, arg1: u64) -> Imm64;
    fn u64_from_ieee32(&mut self, arg0: Ieee32) -> u64;
    fn u64_from_ieee64(&mut self, arg0: Ieee64) -> u64;
    fn multi_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_int_lane(&mut self, arg0: Type) -> Option<u32>;
    fn dynamic_fp_lane(&mut self, arg0: Type) -> Option<u32>;
    fn ty_dyn64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn128_int(&mut self, arg0: Type) -> Option<Type>;
    fn offset32_to_u32(&mut self, arg0: Offset32) -> u32;
    fn intcc_unsigned(&mut self, arg0: &IntCC) -> IntCC;
    fn signed_cond_code(&mut self, arg0: &IntCC) -> Option<IntCC>;
    fn trap_code_division_by_zero(&mut self) -> TrapCode;
    fn trap_code_integer_overflow(&mut self) -> TrapCode;
    fn trap_code_bad_conversion_to_integer(&mut self) -> TrapCode;
    fn range(&mut self, arg0: usize, arg1: usize) -> Range;
    fn range_view(&mut self, arg0: Range) -> RangeView;
    type inst_data_etor_iter: ContextIter<Context = Self, Output = (Type, InstructionData)>;
    fn inst_data_etor(&mut self, arg0: Value) -> Self::inst_data_etor_iter;
    fn make_inst_ctor(&mut self, arg0: Type, arg1: &InstructionData) -> Value;
    fn value_array_2_ctor(&mut self, arg0: Value, arg1: Value) -> ValueArray2;
    fn value_array_3_ctor(&mut self, arg0: Value, arg1: Value, arg2: Value) -> ValueArray3;
    fn remat(&mut self, arg0: Value) -> Value;
    fn subsume(&mut self, arg0: Value) -> Value;
    fn unpack_value_array_2(&mut self, arg0: &ValueArray2) -> (Value, Value);
    fn pack_value_array_2(&mut self, arg0: Value, arg1: Value) -> ValueArray2;
    fn unpack_value_array_3(&mut self, arg0: &ValueArray3) -> (Value, Value, Value);
    fn pack_value_array_3(&mut self, arg0: Value, arg1: Value, arg2: Value) -> ValueArray3;
    fn unpack_block_array_2(&mut self, arg0: &BlockArray2) -> (BlockCall, BlockCall);
    fn pack_block_array_2(&mut self, arg0: BlockCall, arg1: BlockCall) -> BlockArray2;
}

pub trait ContextIter {
    type Context;
    type Output;
    fn next(&mut self, ctx: &mut Self::Context) -> Option<Self::Output>;
}

pub struct ContextIterWrapper<Item, I: Iterator<Item = Item>, C: Context> {
    iter: I,
    _ctx: PhantomData<C>,
}
impl<Item, I: Iterator<Item = Item>, C: Context> From<I> for ContextIterWrapper<Item, I, C> {
    fn from(iter: I) -> Self {
        Self {
            iter,
            _ctx: PhantomData,
        }
    }
}
impl<Item, I: Iterator<Item = Item>, C: Context> ContextIter for ContextIterWrapper<Item, I, C> {
    type Context = C;
    type Output = Item;
    fn next(&mut self, _ctx: &mut Self::Context) -> Option<Self::Output> {
        self.iter.next()
    }
}

// Generated as internal constructor for term simplify.
pub fn constructor_simplify<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> impl ContextIter<Context = C, Output = Value> {
    let mut returns = ConstructorVec::new();
    let v1 = C::inst_data_etor(ctx, arg0);
    let mut v1 = v1;
    while let Some(v2) = v1.next(ctx) {
        match &v2.1 {
            &InstructionData::Binary {
                opcode: ref v5,
                args: ref v6,
            } => {
                match v5 {
                    &Opcode::Iadd => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v68,
                                    args: ref v69,
                                } => {
                                    match v68 {
                                        &Opcode::Iadd => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v2.0 == v11.0 {
                                                                let v70 = C::unpack_value_array_2(
                                                                    ctx, v69,
                                                                );
                                                                let v80 =
                                                                    C::inst_data_etor(ctx, v70.1);
                                                                let mut v80 = v80;
                                                                while let Some(v81) = v80.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v84,
                                                                        imm: v85,
                                                                    } = &v81.1 {
                                                                        if let &Opcode::Iconst = v84 {
                                                                            if v2.0 == v81.0 {
                                                                                let v259 = constructor_iadd(ctx, v2.0, v70.1, v7.1);
                                                                                let v260 = constructor_iadd(ctx, v2.0, v70.0, v259);
                                                                                // Rule at src/opts/cprop.isle line 118.
                                                                                returns.push(v260);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Isub => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v2.0 == v11.0 {
                                                                let v70 = C::unpack_value_array_2(
                                                                    ctx, v69,
                                                                );
                                                                let v80 =
                                                                    C::inst_data_etor(ctx, v70.1);
                                                                let mut v80 = v80;
                                                                while let Some(v81) = v80.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v84,
                                                                        imm: v85,
                                                                    } = &v81.1 {
                                                                        if let &Opcode::Iconst = v84 {
                                                                            if v2.0 == v81.0 {
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v86 = C::u64_from_imm64(ctx, v85);
                                                                                let v272 = C::u64_sub(ctx, v16, v86);
                                                                                let v273 = C::imm64_masked(ctx, v2.0, v272);
                                                                                let v274 = constructor_iconst(ctx, v2.0, v273);
                                                                                let v276 = constructor_iadd(ctx, v2.0, v70.0, v274);
                                                                                // Rule at src/opts/cprop.isle line 140.
                                                                                returns.push(v276);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                let v108 =
                                                                    C::inst_data_etor(ctx, v70.0);
                                                                let mut v108 = v108;
                                                                while let Some(v109) =
                                                                    v108.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v265,
                                                                        imm: v266,
                                                                    } = &v109.1 {
                                                                        if let &Opcode::Iconst = v265 {
                                                                            if v2.0 == v109.0 {
                                                                                let v267 = C::u64_from_imm64(ctx, v266);
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v277 = C::u64_add(ctx, v267, v16);
                                                                                let v278 = C::imm64_masked(ctx, v2.0, v277);
                                                                                let v279 = constructor_iconst(ctx, v2.0, v278);
                                                                                let v280 = constructor_isub(ctx, v2.0, v279, v70.1);
                                                                                // Rule at src/opts/cprop.isle line 144.
                                                                                returns.push(v280);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v24 = C::u64_from_imm64(ctx, v23);
                                            if v24 == 0x0 {
                                                let v25 = C::subsume(ctx, v7.1);
                                                // Rule at src/opts/algebraic.isle line 14.
                                                returns.push(v25);
                                            }
                                            let v252 = constructor_iadd(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 91.
                                            returns.push(v252);
                                        }
                                        let v30 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v31) = v30 {
                                            if v19.0 == v31 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v11.0 == v19.0 {
                                                                let v24 =
                                                                    C::u64_from_imm64(ctx, v23);
                                                                let v16 =
                                                                    C::u64_from_imm64(ctx, v15);
                                                                let v188 =
                                                                    C::u64_add(ctx, v24, v16);
                                                                let v189 =
                                                                    C::imm64_masked(ctx, v31, v188);
                                                                let v190 = constructor_iconst(
                                                                    ctx, v31, v189,
                                                                );
                                                                let v191 = C::subsume(ctx, v190);
                                                                // Rule at src/opts/cprop.isle line 3.
                                                                returns.push(v191);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v122 = C::remat(ctx, arg0);
                                        // Rule at src/opts/algebraic.isle line 204.
                                        returns.push(v122);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/algebraic.isle line 10.
                                            returns.push(v17);
                                        }
                                    }
                                    let v122 = C::remat(ctx, arg0);
                                    // Rule at src/opts/algebraic.isle line 206.
                                    returns.push(v122);
                                }
                            }
                        }
                    }
                    &Opcode::Isub => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v68,
                                    args: ref v69,
                                } => {
                                    match v68 {
                                        &Opcode::Iadd => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v2.0 == v11.0 {
                                                                let v70 = C::unpack_value_array_2(
                                                                    ctx, v69,
                                                                );
                                                                let v80 =
                                                                    C::inst_data_etor(ctx, v70.1);
                                                                let mut v80 = v80;
                                                                while let Some(v81) = v80.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v84,
                                                                        imm: v85,
                                                                    } = &v81.1 {
                                                                        if let &Opcode::Iconst = v84 {
                                                                            if v2.0 == v81.0 {
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v86 = C::u64_from_imm64(ctx, v85);
                                                                                let v272 = C::u64_sub(ctx, v16, v86);
                                                                                let v273 = C::imm64_masked(ctx, v2.0, v272);
                                                                                let v274 = constructor_iconst(ctx, v2.0, v273);
                                                                                let v275 = constructor_isub(ctx, v2.0, v70.0, v274);
                                                                                // Rule at src/opts/cprop.isle line 136.
                                                                                returns.push(v275);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Isub => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v2.0 == v11.0 {
                                                                let v70 = C::unpack_value_array_2(
                                                                    ctx, v69,
                                                                );
                                                                let v80 =
                                                                    C::inst_data_etor(ctx, v70.1);
                                                                let mut v80 = v80;
                                                                while let Some(v81) = v80.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v84,
                                                                        imm: v85,
                                                                    } = &v81.1 {
                                                                        if let &Opcode::Iconst = v84 {
                                                                            if v2.0 == v81.0 {
                                                                                let v86 = C::u64_from_imm64(ctx, v85);
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v261 = C::u64_add(ctx, v86, v16);
                                                                                let v262 = C::imm64_masked(ctx, v2.0, v261);
                                                                                let v263 = constructor_iconst(ctx, v2.0, v262);
                                                                                let v264 = constructor_isub(ctx, v2.0, v70.0, v263);
                                                                                // Rule at src/opts/cprop.isle line 128.
                                                                                returns.push(v264);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                let v108 =
                                                                    C::inst_data_etor(ctx, v70.0);
                                                                let mut v108 = v108;
                                                                while let Some(v109) =
                                                                    v108.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v265,
                                                                        imm: v266,
                                                                    } = &v109.1 {
                                                                        if let &Opcode::Iconst = v265 {
                                                                            if v2.0 == v109.0 {
                                                                                let v267 = C::u64_from_imm64(ctx, v266);
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v268 = C::u64_sub(ctx, v267, v16);
                                                                                let v269 = C::imm64_masked(ctx, v2.0, v268);
                                                                                let v270 = constructor_iconst(ctx, v2.0, v269);
                                                                                let v271 = constructor_isub(ctx, v2.0, v270, v70.1);
                                                                                // Rule at src/opts/cprop.isle line 132.
                                                                                returns.push(v271);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v24 = C::u64_from_imm64(ctx, v23);
                                            if v24 == 0x0 {
                                                let v26 = constructor_ineg(ctx, v2.0, v7.1);
                                                // Rule at src/opts/algebraic.isle line 24.
                                                returns.push(v26);
                                            }
                                            let v253 = constructor_isub(ctx, v2.0, v7.1, v7.0);
                                            let v254 = constructor_ineg(ctx, v2.0, v253);
                                            // Rule at src/opts/cprop.isle line 96.
                                            returns.push(v254);
                                        }
                                        let v30 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v31) = v30 {
                                            if v19.0 == v31 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v11.0 == v19.0 {
                                                                let v24 =
                                                                    C::u64_from_imm64(ctx, v23);
                                                                let v16 =
                                                                    C::u64_from_imm64(ctx, v15);
                                                                let v192 =
                                                                    C::u64_sub(ctx, v24, v16);
                                                                let v193 =
                                                                    C::imm64_masked(ctx, v31, v192);
                                                                let v194 = constructor_iconst(
                                                                    ctx, v31, v193,
                                                                );
                                                                let v195 = C::subsume(ctx, v194);
                                                                // Rule at src/opts/cprop.isle line 9.
                                                                returns.push(v195);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v122 = C::remat(ctx, arg0);
                                        // Rule at src/opts/algebraic.isle line 208.
                                        returns.push(v122);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/algebraic.isle line 19.
                                            returns.push(v17);
                                        }
                                    }
                                    let v122 = C::remat(ctx, arg0);
                                    // Rule at src/opts/algebraic.isle line 210.
                                    returns.push(v122);
                                }
                            }
                        }
                    }
                    &Opcode::Imul => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v68,
                                    args: ref v69,
                                } => {
                                    if let &Opcode::Imul = v68 {
                                        if v2.0 == v19.0 {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v14,
                                                    imm: v15,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Iconst = v14 {
                                                        if v2.0 == v11.0 {
                                                            let v70 =
                                                                C::unpack_value_array_2(ctx, v69);
                                                            let v80 = C::inst_data_etor(ctx, v70.1);
                                                            let mut v80 = v80;
                                                            while let Some(v81) = v80.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v84,
                                                                    imm: v85,
                                                                } = &v81.1 {
                                                                    if let &Opcode::Iconst = v84 {
                                                                        if v2.0 == v81.0 {
                                                                            let v281 = constructor_imul(ctx, v2.0, v70.1, v7.1);
                                                                            let v282 = constructor_imul(ctx, v2.0, v70.0, v281);
                                                                            // Rule at src/opts/cprop.isle line 149.
                                                                            returns.push(v282);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v24 = C::u64_from_imm64(ctx, v23);
                                            match v24 {
                                                0x0 => {
                                                    let v28 = C::imm64(ctx, 0x0);
                                                    let v29 = constructor_iconst(ctx, v2.0, v28);
                                                    // Rule at src/opts/algebraic.isle line 44.
                                                    returns.push(v29);
                                                }
                                                0x1 => {
                                                    let v25 = C::subsume(ctx, v7.1);
                                                    // Rule at src/opts/algebraic.isle line 34.
                                                    returns.push(v25);
                                                }
                                                _ => {}
                                            }
                                            let v255 = constructor_imul(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 99.
                                            returns.push(v255);
                                        }
                                        let v30 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v31) = v30 {
                                            if v19.0 == v31 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v11.0 == v19.0 {
                                                                let v24 =
                                                                    C::u64_from_imm64(ctx, v23);
                                                                let v16 =
                                                                    C::u64_from_imm64(ctx, v15);
                                                                let v196 =
                                                                    C::u64_mul(ctx, v24, v16);
                                                                let v197 =
                                                                    C::imm64_masked(ctx, v31, v196);
                                                                let v198 = constructor_iconst(
                                                                    ctx, v31, v197,
                                                                );
                                                                let v199 = C::subsume(ctx, v198);
                                                                // Rule at src/opts/cprop.isle line 15.
                                                                returns.push(v199);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v95 = C::simm32(ctx, v23);
                                        if let Some(v96) = v95 {
                                            if v96 == 0x2 {
                                                let v97 = constructor_iadd(ctx, v2.0, v7.1, v7.1);
                                                // Rule at src/opts/algebraic.isle line 166.
                                                returns.push(v97);
                                            }
                                        }
                                        let v103 = C::imm64_power_of_two(ctx, v23);
                                        if let Some(v104) = v103 {
                                            let v105 = C::imm64(ctx, v104);
                                            let v106 = constructor_iconst(ctx, v2.0, v105);
                                            let v107 = constructor_ishl(ctx, v2.0, v7.1, v106);
                                            // Rule at src/opts/algebraic.isle line 175.
                                            returns.push(v107);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    match v16 {
                                        0x0 => {
                                            if v2.0 == v11.0 {
                                                let v28 = C::imm64(ctx, 0x0);
                                                let v29 = constructor_iconst(ctx, v2.0, v28);
                                                // Rule at src/opts/algebraic.isle line 40.
                                                returns.push(v29);
                                            }
                                        }
                                        0x1 => {
                                            if v2.0 == v11.0 {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/algebraic.isle line 30.
                                                returns.push(v17);
                                            }
                                        }
                                        _ => {}
                                    }
                                    let v92 = C::simm32(ctx, v15);
                                    if let Some(v93) = v92 {
                                        if v93 == 0x2 {
                                            let v94 = constructor_iadd(ctx, v2.0, v7.0, v7.0);
                                            // Rule at src/opts/algebraic.isle line 164.
                                            returns.push(v94);
                                        }
                                    }
                                    let v98 = C::imm64_power_of_two(ctx, v15);
                                    if let Some(v99) = v98 {
                                        let v100 = C::imm64(ctx, v99);
                                        let v101 = constructor_iconst(ctx, v2.0, v100);
                                        let v102 = constructor_ishl(ctx, v2.0, v7.0, v101);
                                        // Rule at src/opts/algebraic.isle line 173.
                                        returns.push(v102);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Udiv => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x1 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/algebraic.isle line 54.
                                            returns.push(v17);
                                        }
                                    }
                                    let v30 = C::fits_in_64(ctx, v2.0);
                                    if let Some(v31) = v30 {
                                        if v11.0 == v31 {
                                            let v18 = C::inst_data_etor(ctx, v7.0);
                                            let mut v18 = v18;
                                            while let Some(v19) = v18.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v22,
                                                    imm: v23,
                                                } = &v19.1
                                                {
                                                    if let &Opcode::Iconst = v22 {
                                                        let v24 = C::u64_from_imm64(ctx, v23);
                                                        let v205 = C::u64_udiv(ctx, v24, v16);
                                                        if let Some(v206) = v205 {
                                                            if v11.0 == v19.0 {
                                                                let v207 =
                                                                    C::imm64_masked(ctx, v31, v206);
                                                                let v208 = constructor_iconst(
                                                                    ctx, v31, v207,
                                                                );
                                                                let v209 = C::subsume(ctx, v208);
                                                                // Rule at src/opts/cprop.isle line 28.
                                                                returns.push(v209);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Sdiv => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x1 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/algebraic.isle line 50.
                                            returns.push(v17);
                                        }
                                    }
                                    let v30 = C::fits_in_64(ctx, v2.0);
                                    if let Some(v31) = v30 {
                                        if v11.0 == v31 {
                                            let v18 = C::inst_data_etor(ctx, v7.0);
                                            let mut v18 = v18;
                                            while let Some(v19) = v18.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v22,
                                                    imm: v23,
                                                } = &v19.1
                                                {
                                                    if let &Opcode::Iconst = v22 {
                                                        let v24 = C::u64_from_imm64(ctx, v23);
                                                        let v200 = C::u64_sdiv(ctx, v24, v16);
                                                        if let Some(v201) = v200 {
                                                            if v11.0 == v19.0 {
                                                                let v202 =
                                                                    C::imm64_masked(ctx, v31, v201);
                                                                let v203 = constructor_iconst(
                                                                    ctx, v31, v202,
                                                                );
                                                                let v204 = C::subsume(ctx, v203);
                                                                // Rule at src/opts/cprop.isle line 21.
                                                                returns.push(v204);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Band => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v68,
                                    args: ref v69,
                                } => {
                                    if let &Opcode::Band = v68 {
                                        if v2.0 == v19.0 {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v14,
                                                    imm: v15,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Iconst = v14 {
                                                        if v2.0 == v11.0 {
                                                            let v70 =
                                                                C::unpack_value_array_2(ctx, v69);
                                                            let v80 = C::inst_data_etor(ctx, v70.1);
                                                            let mut v80 = v80;
                                                            while let Some(v81) = v80.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v84,
                                                                    imm: v85,
                                                                } = &v81.1 {
                                                                    if let &Opcode::Iconst = v84 {
                                                                        if v2.0 == v81.0 {
                                                                            let v285 = constructor_band(ctx, v2.0, v70.1, v7.1);
                                                                            let v286 = constructor_band(ctx, v2.0, v70.0, v285);
                                                                            // Rule at src/opts/cprop.isle line 155.
                                                                            returns.push(v286);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        let v24 = C::u64_from_imm64(ctx, v23);
                                        match v24 {
                                            0x0 => {
                                                if v2.0 == v19.0 {
                                                    let v28 = C::imm64(ctx, 0x0);
                                                    let v29 = constructor_iconst(ctx, v2.0, v28);
                                                    // Rule at src/opts/algebraic.isle line 122.
                                                    returns.push(v29);
                                                }
                                            }
                                            0xFFFFFFFF => {
                                                if v2.0 == I32 {
                                                    if v19.0 == I32 {
                                                        let v25 = C::subsume(ctx, v7.1);
                                                        // Rule at src/opts/algebraic.isle line 116.
                                                        returns.push(v25);
                                                    }
                                                }
                                            }
                                            0xFFFFFFFFFFFFFFFF => {
                                                if v2.0 == I64 {
                                                    if v19.0 == I64 {
                                                        let v25 = C::subsume(ctx, v7.1);
                                                        // Rule at src/opts/algebraic.isle line 118.
                                                        returns.push(v25);
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                        let v30 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v31) = v30 {
                                            if v19.0 == v31 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v11.0 == v19.0 {
                                                                let v16 =
                                                                    C::u64_from_imm64(ctx, v15);
                                                                let v214 =
                                                                    C::u64_and(ctx, v24, v16);
                                                                let v215 =
                                                                    C::imm64_masked(ctx, v31, v214);
                                                                let v216 = constructor_iconst(
                                                                    ctx, v31, v215,
                                                                );
                                                                let v217 = C::subsume(ctx, v216);
                                                                // Rule at src/opts/cprop.isle line 41.
                                                                returns.push(v217);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        if v2.0 == v19.0 {
                                            let v257 = constructor_band(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 106.
                                            returns.push(v257);
                                        }
                                        let v122 = C::remat(ctx, arg0);
                                        // Rule at src/opts/algebraic.isle line 212.
                                        returns.push(v122);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    match v16 {
                                        0x0 => {
                                            if v2.0 == v11.0 {
                                                let v28 = C::imm64(ctx, 0x0);
                                                let v29 = constructor_iconst(ctx, v2.0, v28);
                                                // Rule at src/opts/algebraic.isle line 121.
                                                returns.push(v29);
                                            }
                                        }
                                        0xFFFFFFFF => {
                                            if v2.0 == I32 {
                                                if v11.0 == I32 {
                                                    let v17 = C::subsume(ctx, v7.0);
                                                    // Rule at src/opts/algebraic.isle line 115.
                                                    returns.push(v17);
                                                }
                                            }
                                        }
                                        0xFFFFFFFFFFFFFFFF => {
                                            if v2.0 == I64 {
                                                if v11.0 == I64 {
                                                    let v17 = C::subsume(ctx, v7.0);
                                                    // Rule at src/opts/algebraic.isle line 117.
                                                    returns.push(v17);
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                    let v122 = C::remat(ctx, arg0);
                                    // Rule at src/opts/algebraic.isle line 214.
                                    returns.push(v122);
                                }
                            }
                        }
                        if v7.0 == v7.1 {
                            // Rule at src/opts/algebraic.isle line 114.
                            returns.push(v7.0);
                        }
                    }
                    &Opcode::Bor => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v68,
                                    args: ref v69,
                                } => {
                                    match v68 {
                                        &Opcode::Band => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    match &v11.1 {
                                                        &InstructionData::Unary {
                                                            opcode: ref v36,
                                                            arg: v37,
                                                        } => {
                                                            if let &Opcode::Bnot = v36 {
                                                                if v2.0 == v11.0 {
                                                                    let v70 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v69,
                                                                        );
                                                                    if v37 == v70.1 {
                                                                        let v73 = constructor_bor(
                                                                            ctx, v2.0, v70.0, v7.1,
                                                                        );
                                                                        // Rule at src/opts/algebraic.isle line 136.
                                                                        returns.push(v73);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &InstructionData::UnaryImm {
                                                            opcode: ref v14,
                                                            imm: v15,
                                                        } => {
                                                            if let &Opcode::Iconst = v14 {
                                                                if v2.0 == v11.0 {
                                                                    let v70 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v69,
                                                                        );
                                                                    let v80 = C::inst_data_etor(
                                                                        ctx, v70.1,
                                                                    );
                                                                    let mut v80 = v80;
                                                                    while let Some(v81) =
                                                                        v80.next(ctx)
                                                                    {
                                                                        if let &InstructionData::UnaryImm {
                                                                            opcode: ref v84,
                                                                            imm: v85,
                                                                        } = &v81.1 {
                                                                            if let &Opcode::Iconst = v84 {
                                                                                let v87 = C::ty_mask(ctx, v2.0);
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v88 = C::u64_and(ctx, v87, v16);
                                                                                let v86 = C::u64_from_imm64(ctx, v85);
                                                                                let v89 = C::u64_not(ctx, v86);
                                                                                let v90 = C::u64_and(ctx, v87, v89);
                                                                                let v91 = C::u64_eq(ctx, v88, v90);
                                                                                if v91 == true {
                                                                                    if v2.0 == v81.0 {
                                                                                        let v73 = constructor_bor(ctx, v2.0, v70.0, v7.1);
                                                                                        // Rule at src/opts/algebraic.isle line 156.
                                                                                        returns.push(v73);
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Bor => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v2.0 == v11.0 {
                                                                let v70 = C::unpack_value_array_2(
                                                                    ctx, v69,
                                                                );
                                                                let v80 =
                                                                    C::inst_data_etor(ctx, v70.1);
                                                                let mut v80 = v80;
                                                                while let Some(v81) = v80.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v84,
                                                                        imm: v85,
                                                                    } = &v81.1 {
                                                                        if let &Opcode::Iconst = v84 {
                                                                            if v2.0 == v81.0 {
                                                                                let v283 = constructor_bor(ctx, v2.0, v70.1, v7.1);
                                                                                let v284 = constructor_bor(ctx, v2.0, v70.0, v283);
                                                                                // Rule at src/opts/cprop.isle line 152.
                                                                                returns.push(v284);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v43,
                                    arg: v44,
                                } => {
                                    if let &Opcode::Bnot = v43 {
                                        if v2.0 == v19.0 {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::Binary {
                                                    opcode: ref v74,
                                                    args: ref v75,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Band = v74 {
                                                        if v2.0 == v11.0 {
                                                            let v76 =
                                                                C::unpack_value_array_2(ctx, v75);
                                                            if v44 == v76.1 {
                                                                let v79 = constructor_bor(
                                                                    ctx, v2.0, v76.0, v7.0,
                                                                );
                                                                // Rule at src/opts/algebraic.isle line 145.
                                                                returns.push(v79);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v24 = C::u64_from_imm64(ctx, v23);
                                            if v24 == 0x0 {
                                                let v25 = C::subsume(ctx, v7.1);
                                                // Rule at src/opts/algebraic.isle line 86.
                                                returns.push(v25);
                                            }
                                            let v256 = constructor_bor(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 103.
                                            returns.push(v256);
                                        }
                                        let v30 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v31) = v30 {
                                            if v19.0 == v31 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v11.0 == v19.0 {
                                                                let v24 =
                                                                    C::u64_from_imm64(ctx, v23);
                                                                let v16 =
                                                                    C::u64_from_imm64(ctx, v15);
                                                                let v210 = C::u64_or(ctx, v24, v16);
                                                                let v211 =
                                                                    C::imm64_masked(ctx, v31, v210);
                                                                let v212 = constructor_iconst(
                                                                    ctx, v31, v211,
                                                                );
                                                                let v213 = C::subsume(ctx, v212);
                                                                // Rule at src/opts/cprop.isle line 35.
                                                                returns.push(v213);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v122 = C::remat(ctx, arg0);
                                        // Rule at src/opts/algebraic.isle line 216.
                                        returns.push(v122);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/algebraic.isle line 82.
                                            returns.push(v17);
                                        }
                                    }
                                    let v122 = C::remat(ctx, arg0);
                                    // Rule at src/opts/algebraic.isle line 218.
                                    returns.push(v122);
                                }
                            }
                        }
                        if v7.0 == v7.1 {
                            let v17 = C::subsume(ctx, v7.0);
                            // Rule at src/opts/algebraic.isle line 90.
                            returns.push(v17);
                        }
                    }
                    &Opcode::Bxor => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v68,
                                    args: ref v69,
                                } => {
                                    if let &Opcode::Bxor = v68 {
                                        if v2.0 == v19.0 {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v14,
                                                    imm: v15,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Iconst = v14 {
                                                        if v2.0 == v11.0 {
                                                            let v70 =
                                                                C::unpack_value_array_2(ctx, v69);
                                                            let v80 = C::inst_data_etor(ctx, v70.1);
                                                            let mut v80 = v80;
                                                            while let Some(v81) = v80.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v84,
                                                                    imm: v85,
                                                                } = &v81.1 {
                                                                    if let &Opcode::Iconst = v84 {
                                                                        if v2.0 == v81.0 {
                                                                            let v287 = constructor_bxor(ctx, v2.0, v70.1, v7.1);
                                                                            let v288 = constructor_bxor(ctx, v2.0, v70.0, v287);
                                                                            // Rule at src/opts/cprop.isle line 158.
                                                                            returns.push(v288);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v43,
                                    arg: v44,
                                } => {
                                    if let &Opcode::Bnot = v43 {
                                        match v2.0 {
                                            I32 => {
                                                if v19.0 == I32 {
                                                    if v7.1 == v44 {
                                                        let v40 = C::imm64(ctx, 0xFFFFFFFF);
                                                        let v41 = constructor_iconst(ctx, I32, v40);
                                                        let v42 = C::subsume(ctx, v41);
                                                        // Rule at src/opts/algebraic.isle line 109.
                                                        returns.push(v42);
                                                    }
                                                }
                                            }
                                            I64 => {
                                                if v19.0 == I64 {
                                                    if v7.1 == v44 {
                                                        let v47 = C::imm64(ctx, 0xFFFFFFFFFFFFFFFF);
                                                        let v48 = constructor_iconst(ctx, I64, v47);
                                                        let v49 = C::subsume(ctx, v48);
                                                        // Rule at src/opts/algebraic.isle line 111.
                                                        returns.push(v49);
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v24 = C::u64_from_imm64(ctx, v23);
                                            if v24 == 0x0 {
                                                let v25 = C::subsume(ctx, v7.1);
                                                // Rule at src/opts/algebraic.isle line 98.
                                                returns.push(v25);
                                            }
                                            let v258 = constructor_bxor(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 109.
                                            returns.push(v258);
                                        }
                                        let v30 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v31) = v30 {
                                            if v19.0 == v31 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v11.0 == v19.0 {
                                                                let v24 =
                                                                    C::u64_from_imm64(ctx, v23);
                                                                let v16 =
                                                                    C::u64_from_imm64(ctx, v15);
                                                                let v218 =
                                                                    C::u64_xor(ctx, v24, v16);
                                                                let v219 =
                                                                    C::imm64_masked(ctx, v31, v218);
                                                                let v220 = constructor_iconst(
                                                                    ctx, v31, v219,
                                                                );
                                                                let v221 = C::subsume(ctx, v220);
                                                                // Rule at src/opts/cprop.isle line 47.
                                                                returns.push(v221);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v122 = C::remat(ctx, arg0);
                                        // Rule at src/opts/algebraic.isle line 220.
                                        returns.push(v122);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            match &v11.1 {
                                &InstructionData::Unary {
                                    opcode: ref v36,
                                    arg: v37,
                                } => {
                                    if let &Opcode::Bnot = v36 {
                                        if v7.0 == v37 {
                                            match v2.0 {
                                                I32 => {
                                                    if v11.0 == I32 {
                                                        let v40 = C::imm64(ctx, 0xFFFFFFFF);
                                                        let v41 = constructor_iconst(ctx, I32, v40);
                                                        let v42 = C::subsume(ctx, v41);
                                                        // Rule at src/opts/algebraic.isle line 108.
                                                        returns.push(v42);
                                                    }
                                                }
                                                I64 => {
                                                    if v11.0 == I64 {
                                                        let v47 = C::imm64(ctx, 0xFFFFFFFFFFFFFFFF);
                                                        let v48 = constructor_iconst(ctx, I64, v47);
                                                        let v49 = C::subsume(ctx, v48);
                                                        // Rule at src/opts/algebraic.isle line 110.
                                                        returns.push(v49);
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v14,
                                    imm: v15,
                                } => {
                                    if let &Opcode::Iconst = v14 {
                                        let v16 = C::u64_from_imm64(ctx, v15);
                                        if v16 == 0x0 {
                                            if v2.0 == v11.0 {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/algebraic.isle line 94.
                                                returns.push(v17);
                                            }
                                        }
                                        let v122 = C::remat(ctx, arg0);
                                        // Rule at src/opts/algebraic.isle line 222.
                                        returns.push(v122);
                                    }
                                }
                                _ => {}
                            }
                        }
                        if v7.0 == v7.1 {
                            let v30 = C::fits_in_64(ctx, v2.0);
                            if let Some(v31) = v30 {
                                let v32 = C::ty_int(ctx, v31);
                                if let Some(v33) = v32 {
                                    let v28 = C::imm64(ctx, 0x0);
                                    let v34 = constructor_iconst(ctx, v33, v28);
                                    let v35 = C::subsume(ctx, v34);
                                    // Rule at src/opts/algebraic.isle line 104.
                                    returns.push(v35);
                                }
                            }
                        }
                    }
                    &Opcode::Rotl => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/algebraic.isle line 76.
                                            returns.push(v17);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Rotr => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/algebraic.isle line 72.
                                            returns.push(v17);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ishl => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v30 = C::fits_in_64(ctx, v2.0);
                                    if let Some(v31) = v30 {
                                        let v18 = C::inst_data_etor(ctx, v7.0);
                                        let mut v18 = v18;
                                        while let Some(v19) = v18.next(ctx) {
                                            match &v19.1 {
                                                &InstructionData::Binary {
                                                    opcode: ref v68,
                                                    args: ref v69,
                                                } => {
                                                    match v68 {
                                                        &Opcode::Ushr => {
                                                            if v19.0 == v31 {
                                                                let v70 = C::unpack_value_array_2(
                                                                    ctx, v69,
                                                                );
                                                                let v80 =
                                                                    C::inst_data_etor(ctx, v70.1);
                                                                let mut v80 = v80;
                                                                while let Some(v81) = v80.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v84,
                                                                        imm: v85,
                                                                    } = &v81.1 {
                                                                        if let &Opcode::Iconst = v84 {
                                                                            if v15 == v85 {
                                                                                let v47 = C::imm64(ctx, 0xFFFFFFFFFFFFFFFF);
                                                                                let v119 = C::imm64_shl(ctx, v31, v47, v85);
                                                                                let v120 = constructor_iconst(ctx, v31, v119);
                                                                                let v121 = constructor_band(ctx, v31, v70.0, v120);
                                                                                // Rule at src/opts/algebraic.isle line 190.
                                                                                returns.push(v121);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &Opcode::Sshr => {
                                                            if v19.0 == v31 {
                                                                let v70 = C::unpack_value_array_2(
                                                                    ctx, v69,
                                                                );
                                                                let v80 =
                                                                    C::inst_data_etor(ctx, v70.1);
                                                                let mut v80 = v80;
                                                                while let Some(v81) = v80.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v84,
                                                                        imm: v85,
                                                                    } = &v81.1 {
                                                                        if let &Opcode::Iconst = v84 {
                                                                            if v15 == v85 {
                                                                                let v47 = C::imm64(ctx, 0xFFFFFFFFFFFFFFFF);
                                                                                let v119 = C::imm64_shl(ctx, v31, v47, v85);
                                                                                let v120 = constructor_iconst(ctx, v31, v119);
                                                                                let v121 = constructor_band(ctx, v31, v70.0, v120);
                                                                                // Rule at src/opts/algebraic.isle line 195.
                                                                                returns.push(v121);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                                &InstructionData::UnaryImm {
                                                    opcode: ref v22,
                                                    imm: v23,
                                                } => {
                                                    if let &Opcode::Iconst = v22 {
                                                        if v19.0 == v31 {
                                                            let v229 =
                                                                C::imm64_shl(ctx, v31, v23, v15);
                                                            let v230 =
                                                                constructor_iconst(ctx, v31, v229);
                                                            let v231 = C::subsume(ctx, v230);
                                                            // Rule at src/opts/cprop.isle line 58.
                                                            returns.push(v231);
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                    }
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/algebraic.isle line 60.
                                            returns.push(v17);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ushr => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v18 = C::inst_data_etor(ctx, v7.0);
                                    let mut v18 = v18;
                                    while let Some(v19) = v18.next(ctx) {
                                        match &v19.1 {
                                            &InstructionData::Binary {
                                                opcode: ref v68,
                                                args: ref v69,
                                            } => {
                                                if let &Opcode::Ishl = v68 {
                                                    if v2.0 == I64 {
                                                        if v19.0 == I64 {
                                                            let v92 = C::simm32(ctx, v15);
                                                            if let Some(v93) = v92 {
                                                                if v93 == 0x20 {
                                                                    let v70 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v69,
                                                                        );
                                                                    let v80 = C::inst_data_etor(
                                                                        ctx, v70.1,
                                                                    );
                                                                    let mut v80 = v80;
                                                                    while let Some(v81) =
                                                                        v80.next(ctx)
                                                                    {
                                                                        if let &InstructionData::UnaryImm {
                                                                            opcode: ref v84,
                                                                            imm: v85,
                                                                        } = &v81.1 {
                                                                            if let &Opcode::Iconst = v84 {
                                                                                let v115 = C::simm32(ctx, v85);
                                                                                if let Some(v116) = v115 {
                                                                                    if v116 == 0x20 {
                                                                                        let v108 = C::inst_data_etor(ctx, v70.0);
                                                                                        let mut v108 = v108;
                                                                                        while let Some(v109) = v108.next(ctx) {
                                                                                            if v109.0 == I64 {
                                                                                                if let &InstructionData::Unary {
                                                                                                    opcode: ref v112,
                                                                                                    arg: v113,
                                                                                                } = &v109.1 {
                                                                                                    if let &Opcode::Uextend = v112 {
                                                                                                        let v114 = C::value_type(ctx, v113);
                                                                                                        if v114 == I32 {
                                                                                                            let v117 = constructor_uextend(ctx, I64, v113);
                                                                                                            // Rule at src/opts/algebraic.isle line 179.
                                                                                                            returns.push(v117);
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            &InstructionData::UnaryImm {
                                                opcode: ref v22,
                                                imm: v23,
                                            } => {
                                                if let &Opcode::Iconst = v22 {
                                                    let v30 = C::fits_in_64(ctx, v2.0);
                                                    if let Some(v31) = v30 {
                                                        if v19.0 == v31 {
                                                            let v232 =
                                                                C::imm64_ushr(ctx, v31, v23, v15);
                                                            let v233 =
                                                                constructor_iconst(ctx, v31, v232);
                                                            let v234 = C::subsume(ctx, v233);
                                                            // Rule at src/opts/cprop.isle line 63.
                                                            returns.push(v234);
                                                        }
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/algebraic.isle line 64.
                                            returns.push(v17);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Sshr => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v18 = C::inst_data_etor(ctx, v7.0);
                                    let mut v18 = v18;
                                    while let Some(v19) = v18.next(ctx) {
                                        match &v19.1 {
                                            &InstructionData::Binary {
                                                opcode: ref v68,
                                                args: ref v69,
                                            } => {
                                                if let &Opcode::Ishl = v68 {
                                                    if v2.0 == I64 {
                                                        if v19.0 == I64 {
                                                            let v92 = C::simm32(ctx, v15);
                                                            if let Some(v93) = v92 {
                                                                if v93 == 0x20 {
                                                                    let v70 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v69,
                                                                        );
                                                                    let v80 = C::inst_data_etor(
                                                                        ctx, v70.1,
                                                                    );
                                                                    let mut v80 = v80;
                                                                    while let Some(v81) =
                                                                        v80.next(ctx)
                                                                    {
                                                                        if let &InstructionData::UnaryImm {
                                                                            opcode: ref v84,
                                                                            imm: v85,
                                                                        } = &v81.1 {
                                                                            if let &Opcode::Iconst = v84 {
                                                                                let v115 = C::simm32(ctx, v85);
                                                                                if let Some(v116) = v115 {
                                                                                    if v116 == 0x20 {
                                                                                        let v108 = C::inst_data_etor(ctx, v70.0);
                                                                                        let mut v108 = v108;
                                                                                        while let Some(v109) = v108.next(ctx) {
                                                                                            if v109.0 == I64 {
                                                                                                if let &InstructionData::Unary {
                                                                                                    opcode: ref v112,
                                                                                                    arg: v113,
                                                                                                } = &v109.1 {
                                                                                                    if let &Opcode::Uextend = v112 {
                                                                                                        let v114 = C::value_type(ctx, v113);
                                                                                                        if v114 == I32 {
                                                                                                            let v118 = constructor_sextend(ctx, I64, v113);
                                                                                                            // Rule at src/opts/algebraic.isle line 182.
                                                                                                            returns.push(v118);
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            &InstructionData::UnaryImm {
                                                opcode: ref v22,
                                                imm: v23,
                                            } => {
                                                if let &Opcode::Iconst = v22 {
                                                    let v30 = C::fits_in_64(ctx, v2.0);
                                                    if let Some(v31) = v30 {
                                                        if v19.0 == v31 {
                                                            let v235 =
                                                                C::imm64_sshr(ctx, v31, v23, v15);
                                                            let v236 =
                                                                constructor_iconst(ctx, v31, v235);
                                                            let v237 = C::subsume(ctx, v236);
                                                            // Rule at src/opts/cprop.isle line 68.
                                                            returns.push(v237);
                                                        }
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/algebraic.isle line 68.
                                            returns.push(v17);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
            &InstructionData::IntCompare {
                opcode: ref v129,
                args: ref v130,
                cond: ref v131,
            } => {
                if let &Opcode::Icmp = v129 {
                    match v131 {
                        &IntCC::Equal => {
                            let v30 = C::fits_in_64(ctx, v2.0);
                            if let Some(v31) = v30 {
                                let v32 = C::ty_int(ctx, v31);
                                if let Some(v33) = v32 {
                                    let v132 = C::unpack_value_array_2(ctx, v130);
                                    if v132.0 == v132.1 {
                                        let v186 = C::imm64(ctx, 0x1);
                                        let v187 = constructor_iconst(ctx, v33, v186);
                                        // Rule at src/opts/algebraic.isle line 257.
                                        returns.push(v187);
                                    }
                                }
                            }
                            let v132 = C::unpack_value_array_2(ctx, v130);
                            let v135 = C::inst_data_etor(ctx, v132.0);
                            let mut v135 = v135;
                            while let Some(v136) = v135.next(ctx) {
                                if let &InstructionData::Unary {
                                    opcode: ref v139,
                                    arg: v140,
                                } = &v136.1
                                {
                                    if let &Opcode::Uextend = v139 {
                                        let v141 = C::inst_data_etor(ctx, v140);
                                        let mut v141 = v141;
                                        while let Some(v142) = v141.next(ctx) {
                                            if let &InstructionData::IntCompare {
                                                opcode: ref v145,
                                                args: ref v146,
                                                cond: ref v147,
                                            } = &v142.1
                                            {
                                                if let &Opcode::Icmp = v145 {
                                                    if v2.0 == v142.0 {
                                                        let v151 = C::inst_data_etor(ctx, v132.1);
                                                        let mut v151 = v151;
                                                        while let Some(v152) = v151.next(ctx) {
                                                            if let &InstructionData::UnaryImm {
                                                                opcode: ref v155,
                                                                imm: v156,
                                                            } = &v152.1
                                                            {
                                                                if let &Opcode::Iconst = v155 {
                                                                    let v157 = C::u64_from_imm64(
                                                                        ctx, v156,
                                                                    );
                                                                    if v157 == 0x0 {
                                                                        let v159 =
                                                                            &C::intcc_inverse(
                                                                                ctx, v147,
                                                                            );
                                                                        let v148 =
                                                                            C::unpack_value_array_2(
                                                                                ctx, v146,
                                                                            );
                                                                        let v160 = constructor_icmp(
                                                                            ctx, v2.0, v159,
                                                                            v148.0, v148.1,
                                                                        );
                                                                        let v161 =
                                                                            C::subsume(ctx, v160);
                                                                        // Rule at src/opts/algebraic.isle line 240.
                                                                        returns.push(v161);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &IntCC::NotEqual => {
                            let v30 = C::fits_in_64(ctx, v2.0);
                            if let Some(v31) = v30 {
                                let v32 = C::ty_int(ctx, v31);
                                if let Some(v33) = v32 {
                                    let v132 = C::unpack_value_array_2(ctx, v130);
                                    if v132.0 == v132.1 {
                                        let v28 = C::imm64(ctx, 0x0);
                                        let v34 = constructor_iconst(ctx, v33, v28);
                                        // Rule at src/opts/algebraic.isle line 260.
                                        returns.push(v34);
                                    }
                                }
                            }
                            let v132 = C::unpack_value_array_2(ctx, v130);
                            let v135 = C::inst_data_etor(ctx, v132.0);
                            let mut v135 = v135;
                            while let Some(v136) = v135.next(ctx) {
                                if let &InstructionData::Unary {
                                    opcode: ref v139,
                                    arg: v140,
                                } = &v136.1
                                {
                                    if let &Opcode::Uextend = v139 {
                                        let v141 = C::inst_data_etor(ctx, v140);
                                        let mut v141 = v141;
                                        while let Some(v142) = v141.next(ctx) {
                                            if let &InstructionData::IntCompare {
                                                opcode: ref v145,
                                                args: ref v146,
                                                cond: ref v147,
                                            } = &v142.1
                                            {
                                                if let &Opcode::Icmp = v145 {
                                                    if v2.0 == v142.0 {
                                                        let v151 = C::inst_data_etor(ctx, v132.1);
                                                        let mut v151 = v151;
                                                        while let Some(v152) = v151.next(ctx) {
                                                            if let &InstructionData::UnaryImm {
                                                                opcode: ref v155,
                                                                imm: v156,
                                                            } = &v152.1
                                                            {
                                                                if let &Opcode::Iconst = v155 {
                                                                    let v157 = C::u64_from_imm64(
                                                                        ctx, v156,
                                                                    );
                                                                    if v157 == 0x0 {
                                                                        let v158 =
                                                                            C::subsume(ctx, v140);
                                                                        // Rule at src/opts/algebraic.isle line 234.
                                                                        returns.push(v158);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &IntCC::SignedGreaterThan => {
                            let v30 = C::fits_in_64(ctx, v2.0);
                            if let Some(v31) = v30 {
                                let v32 = C::ty_int(ctx, v31);
                                if let Some(v33) = v32 {
                                    let v132 = C::unpack_value_array_2(ctx, v130);
                                    if v132.0 == v132.1 {
                                        let v28 = C::imm64(ctx, 0x0);
                                        let v34 = constructor_iconst(ctx, v33, v28);
                                        // Rule at src/opts/algebraic.isle line 269.
                                        returns.push(v34);
                                    }
                                }
                            }
                        }
                        &IntCC::SignedGreaterThanOrEqual => {
                            let v30 = C::fits_in_64(ctx, v2.0);
                            if let Some(v31) = v30 {
                                let v32 = C::ty_int(ctx, v31);
                                if let Some(v33) = v32 {
                                    let v132 = C::unpack_value_array_2(ctx, v130);
                                    if v132.0 == v132.1 {
                                        let v186 = C::imm64(ctx, 0x1);
                                        let v187 = constructor_iconst(ctx, v33, v186);
                                        // Rule at src/opts/algebraic.isle line 272.
                                        returns.push(v187);
                                    }
                                }
                            }
                        }
                        &IntCC::SignedLessThan => {
                            let v30 = C::fits_in_64(ctx, v2.0);
                            if let Some(v31) = v30 {
                                let v32 = C::ty_int(ctx, v31);
                                if let Some(v33) = v32 {
                                    let v132 = C::unpack_value_array_2(ctx, v130);
                                    if v132.0 == v132.1 {
                                        let v28 = C::imm64(ctx, 0x0);
                                        let v34 = constructor_iconst(ctx, v33, v28);
                                        // Rule at src/opts/algebraic.isle line 281.
                                        returns.push(v34);
                                    }
                                }
                            }
                        }
                        &IntCC::SignedLessThanOrEqual => {
                            let v30 = C::fits_in_64(ctx, v2.0);
                            if let Some(v31) = v30 {
                                let v32 = C::ty_int(ctx, v31);
                                if let Some(v33) = v32 {
                                    let v132 = C::unpack_value_array_2(ctx, v130);
                                    if v132.0 == v132.1 {
                                        let v186 = C::imm64(ctx, 0x1);
                                        let v187 = constructor_iconst(ctx, v33, v186);
                                        // Rule at src/opts/algebraic.isle line 284.
                                        returns.push(v187);
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedGreaterThan => {
                            let v30 = C::fits_in_64(ctx, v2.0);
                            if let Some(v31) = v30 {
                                let v32 = C::ty_int(ctx, v31);
                                if let Some(v33) = v32 {
                                    let v132 = C::unpack_value_array_2(ctx, v130);
                                    if v132.0 == v132.1 {
                                        let v28 = C::imm64(ctx, 0x0);
                                        let v34 = constructor_iconst(ctx, v33, v28);
                                        // Rule at src/opts/algebraic.isle line 263.
                                        returns.push(v34);
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedGreaterThanOrEqual => {
                            let v30 = C::fits_in_64(ctx, v2.0);
                            if let Some(v31) = v30 {
                                let v32 = C::ty_int(ctx, v31);
                                if let Some(v33) = v32 {
                                    let v132 = C::unpack_value_array_2(ctx, v130);
                                    if v132.0 == v132.1 {
                                        let v186 = C::imm64(ctx, 0x1);
                                        let v187 = constructor_iconst(ctx, v33, v186);
                                        // Rule at src/opts/algebraic.isle line 266.
                                        returns.push(v187);
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedLessThan => {
                            let v30 = C::fits_in_64(ctx, v2.0);
                            if let Some(v31) = v30 {
                                let v32 = C::ty_int(ctx, v31);
                                if let Some(v33) = v32 {
                                    let v132 = C::unpack_value_array_2(ctx, v130);
                                    if v132.0 == v132.1 {
                                        let v28 = C::imm64(ctx, 0x0);
                                        let v34 = constructor_iconst(ctx, v33, v28);
                                        // Rule at src/opts/algebraic.isle line 275.
                                        returns.push(v34);
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedLessThanOrEqual => {
                            let v30 = C::fits_in_64(ctx, v2.0);
                            if let Some(v31) = v30 {
                                let v32 = C::ty_int(ctx, v31);
                                if let Some(v33) = v32 {
                                    let v132 = C::unpack_value_array_2(ctx, v130);
                                    if v132.0 == v132.1 {
                                        let v186 = C::imm64(ctx, 0x1);
                                        let v187 = constructor_iconst(ctx, v33, v186);
                                        // Rule at src/opts/algebraic.isle line 278.
                                        returns.push(v187);
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                    let v132 = C::unpack_value_array_2(ctx, v130);
                    let v135 = C::inst_data_etor(ctx, v132.0);
                    let mut v135 = v135;
                    while let Some(v136) = v135.next(ctx) {
                        if let &InstructionData::UnaryImm {
                            opcode: ref v247,
                            imm: v248,
                        } = &v136.1
                        {
                            if let &Opcode::Iconst = v247 {
                                let v151 = C::inst_data_etor(ctx, v132.1);
                                let mut v151 = v151;
                                while let Some(v152) = v151.next(ctx) {
                                    if let &InstructionData::UnaryImm {
                                        opcode: ref v155,
                                        imm: v156,
                                    } = &v152.1
                                    {
                                        if let &Opcode::Iconst = v155 {
                                            if v136.0 == v152.0 {
                                                let v249 =
                                                    C::imm64_icmp(ctx, v136.0, v131, v248, v156);
                                                let v250 = constructor_iconst(ctx, v2.0, v249);
                                                let v251 = C::subsume(ctx, v250);
                                                // Rule at src/opts/cprop.isle line 79.
                                                returns.push(v251);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            &InstructionData::Ternary {
                opcode: ref v162,
                args: ref v163,
            } => {
                if let &Opcode::Select = v162 {
                    let v164 = C::unpack_value_array_3(ctx, v163);
                    let v168 = C::inst_data_etor(ctx, v164.0);
                    let mut v168 = v168;
                    while let Some(v169) = v168.next(ctx) {
                        match &v169.1 {
                            &InstructionData::Unary {
                                opcode: ref v172,
                                arg: v173,
                            } => {
                                if let &Opcode::Uextend = v172 {
                                    let v174 = C::inst_data_etor(ctx, v173);
                                    let mut v174 = v174;
                                    while let Some(v175) = v174.next(ctx) {
                                        if let &InstructionData::IntCompare {
                                            opcode: ref v178,
                                            args: ref v179,
                                            cond: ref v180,
                                        } = &v175.1
                                        {
                                            if let &Opcode::Icmp = v178 {
                                                let v184 = constructor_select(
                                                    ctx, v2.0, v173, v164.1, v164.2,
                                                );
                                                // Rule at src/opts/algebraic.isle line 248.
                                                returns.push(v184);
                                                // Rule at src/opts/algebraic.isle line 251.
                                                returns.push(v184);
                                            }
                                        }
                                    }
                                }
                            }
                            &InstructionData::UnaryImm {
                                opcode: ref v289,
                                imm: v290,
                            } => {
                                if let &Opcode::Iconst = v289 {
                                    let v291 = C::u64_from_imm64(ctx, v290);
                                    if v291 == 0x0 {
                                        // Rule at src/opts/cprop.isle line 165.
                                        returns.push(v164.2);
                                    }
                                    let v292 = C::u64_is_zero(ctx, v291);
                                    if v292 == false {
                                        // Rule at src/opts/cprop.isle line 162.
                                        returns.push(v164.1);
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                }
            }
            &InstructionData::Unary {
                opcode: ref v50,
                arg: v51,
            } => {
                match v50 {
                    &Opcode::Bnot => {
                        let v52 = C::inst_data_etor(ctx, v51);
                        let mut v52 = v52;
                        while let Some(v53) = v52.next(ctx) {
                            match &v53.1 {
                                &InstructionData::Binary {
                                    opcode: ref v59,
                                    args: ref v60,
                                } => {
                                    match v59 {
                                        &Opcode::Band => {
                                            let v61 = C::unpack_value_array_2(ctx, v60);
                                            let v64 = constructor_bnot(ctx, v2.0, v61.0);
                                            let v65 = constructor_bnot(ctx, v2.0, v61.1);
                                            let v67 = constructor_bor(ctx, v2.0, v64, v65);
                                            // Rule at src/opts/algebraic.isle line 132.
                                            returns.push(v67);
                                        }
                                        &Opcode::Bor => {
                                            if v2.0 == v53.0 {
                                                let v61 = C::unpack_value_array_2(ctx, v60);
                                                let v64 = constructor_bnot(ctx, v2.0, v61.0);
                                                let v65 = constructor_bnot(ctx, v2.0, v61.1);
                                                let v66 = constructor_band(ctx, v2.0, v64, v65);
                                                // Rule at src/opts/algebraic.isle line 129.
                                                returns.push(v66);
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v56,
                                    arg: v57,
                                } => {
                                    if let &Opcode::Bnot = v56 {
                                        if v2.0 == v53.0 {
                                            let v58 = C::subsume(ctx, v57);
                                            // Rule at src/opts/algebraic.isle line 125.
                                            returns.push(v58);
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v222,
                                    imm: v223,
                                } => {
                                    if let &Opcode::Iconst = v222 {
                                        let v30 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v31) = v30 {
                                            if v31 == v53.0 {
                                                let v224 = C::u64_from_imm64(ctx, v223);
                                                let v225 = C::u64_not(ctx, v224);
                                                let v226 = C::imm64_masked(ctx, v31, v225);
                                                let v227 = constructor_iconst(ctx, v31, v226);
                                                let v228 = C::subsume(ctx, v227);
                                                // Rule at src/opts/cprop.isle line 53.
                                                returns.push(v228);
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v122 = C::remat(ctx, arg0);
                        // Rule at src/opts/algebraic.isle line 224.
                        returns.push(v122);
                    }
                    &Opcode::Uextend => {
                        let v30 = C::fits_in_64(ctx, v2.0);
                        if let Some(v31) = v30 {
                            let v52 = C::inst_data_etor(ctx, v51);
                            let mut v52 = v52;
                            while let Some(v53) = v52.next(ctx) {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref v222,
                                    imm: v223,
                                } = &v53.1
                                {
                                    if let &Opcode::Iconst = v222 {
                                        let v238 = C::u64_uextend_imm64(ctx, v53.0, v223);
                                        let v239 = C::imm64(ctx, v238);
                                        let v240 = constructor_iconst(ctx, v31, v239);
                                        let v241 = C::subsume(ctx, v240);
                                        // Rule at src/opts/cprop.isle line 73.
                                        returns.push(v241);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Sextend => {
                        let v30 = C::fits_in_64(ctx, v2.0);
                        if let Some(v31) = v30 {
                            let v52 = C::inst_data_etor(ctx, v51);
                            let mut v52 = v52;
                            while let Some(v53) = v52.next(ctx) {
                                if let &InstructionData::UnaryImm {
                                    opcode: ref v222,
                                    imm: v223,
                                } = &v53.1
                                {
                                    if let &Opcode::Iconst = v222 {
                                        let v242 = C::i64_sextend_imm64(ctx, v53.0, v223);
                                        let v243 = C::i64_as_u64(ctx, v242);
                                        let v244 = C::imm64_masked(ctx, v31, v243);
                                        let v245 = constructor_iconst(ctx, v31, v244);
                                        let v246 = C::subsume(ctx, v245);
                                        // Rule at src/opts/cprop.isle line 76.
                                        returns.push(v246);
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
            &InstructionData::UnaryIeee32 {
                opcode: ref v125,
                imm: v126,
            } => {
                if let &Opcode::F32const = v125 {
                    let v122 = C::remat(ctx, arg0);
                    // Rule at src/opts/algebraic.isle line 228.
                    returns.push(v122);
                }
            }
            &InstructionData::UnaryIeee64 {
                opcode: ref v127,
                imm: v128,
            } => {
                if let &Opcode::F64const = v127 {
                    let v122 = C::remat(ctx, arg0);
                    // Rule at src/opts/algebraic.isle line 230.
                    returns.push(v122);
                }
            }
            &InstructionData::UnaryImm {
                opcode: ref v123,
                imm: v124,
            } => {
                if let &Opcode::Iconst = v123 {
                    let v122 = C::remat(ctx, arg0);
                    // Rule at src/opts/algebraic.isle line 226.
                    returns.push(v122);
                }
            }
            _ => {}
        }
    }
    return ContextIterWrapper::from(returns.into_iter());
}

// Generated as internal constructor for term jump.
pub fn constructor_jump<C: Context>(ctx: &mut C, arg0: Type, arg1: BlockCall) -> Value {
    let v3 = InstructionData::Jump {
        opcode: Opcode::Jump,
        destination: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 358.
    return v4;
}

// Generated as internal constructor for term brif.
pub fn constructor_brif<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: BlockCall,
    arg3: BlockCall,
) -> Value {
    let v5 = &C::pack_block_array_2(ctx, arg2, arg3);
    let v6 = InstructionData::Brif {
        opcode: Opcode::Brif,
        arg: arg1,
        blocks: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 367.
    return v7;
}

// Generated as internal constructor for term br_table.
pub fn constructor_br_table<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Block,
    arg3: JumpTable,
) -> Value {
    let v5 = InstructionData::BranchTable {
        opcode: Opcode::BrTable,
        arg: arg1,
        destination: arg2,
        table: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 376.
    return v6;
}

// Generated as internal constructor for term debugtrap.
pub fn constructor_debugtrap<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::Debugtrap,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 385.
    return v3;
}

// Generated as internal constructor for term trap.
pub fn constructor_trap<C: Context>(ctx: &mut C, arg0: Type, arg1: &TrapCode) -> Value {
    let v3 = InstructionData::Trap {
        opcode: Opcode::Trap,
        code: arg1.clone(),
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 394.
    return v4;
}

// Generated as internal constructor for term trapz.
pub fn constructor_trapz<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: &TrapCode,
) -> Value {
    let v4 = InstructionData::CondTrap {
        opcode: Opcode::Trapz,
        arg: arg1,
        code: arg2.clone(),
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 403.
    return v5;
}

// Generated as internal constructor for term resumable_trap.
pub fn constructor_resumable_trap<C: Context>(ctx: &mut C, arg0: Type, arg1: &TrapCode) -> Value {
    let v3 = InstructionData::Trap {
        opcode: Opcode::ResumableTrap,
        code: arg1.clone(),
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 412.
    return v4;
}

// Generated as internal constructor for term trapnz.
pub fn constructor_trapnz<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: &TrapCode,
) -> Value {
    let v4 = InstructionData::CondTrap {
        opcode: Opcode::Trapnz,
        arg: arg1,
        code: arg2.clone(),
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 421.
    return v5;
}

// Generated as internal constructor for term resumable_trapnz.
pub fn constructor_resumable_trapnz<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: &TrapCode,
) -> Value {
    let v4 = InstructionData::CondTrap {
        opcode: Opcode::ResumableTrapnz,
        arg: arg1,
        code: arg2.clone(),
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 430.
    return v5;
}

// Generated as internal constructor for term func_addr.
pub fn constructor_func_addr<C: Context>(ctx: &mut C, arg0: Type, arg1: FuncRef) -> Value {
    let v3 = InstructionData::FuncAddr {
        opcode: Opcode::FuncAddr,
        func_ref: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 439.
    return v4;
}

// Generated as internal constructor for term splat.
pub fn constructor_splat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Splat,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 448.
    return v4;
}

// Generated as internal constructor for term swizzle.
pub fn constructor_swizzle<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Swizzle,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 457.
    return v6;
}

// Generated as internal constructor for term insertlane.
pub fn constructor_insertlane<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Uimm8,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v6 = InstructionData::TernaryImm8 {
        opcode: Opcode::Insertlane,
        args: v5.clone(),
        imm: arg3,
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 466.
    return v7;
}

// Generated as internal constructor for term extractlane.
pub fn constructor_extractlane<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Uimm8,
) -> Value {
    let v4 = InstructionData::BinaryImm8 {
        opcode: Opcode::Extractlane,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 475.
    return v5;
}

// Generated as internal constructor for term smin.
pub fn constructor_smin<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Smin,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 484.
    return v6;
}

// Generated as internal constructor for term umin.
pub fn constructor_umin<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Umin,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 493.
    return v6;
}

// Generated as internal constructor for term smax.
pub fn constructor_smax<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Smax,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 502.
    return v6;
}

// Generated as internal constructor for term umax.
pub fn constructor_umax<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Umax,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 511.
    return v6;
}

// Generated as internal constructor for term avg_round.
pub fn constructor_avg_round<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::AvgRound,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 520.
    return v6;
}

// Generated as internal constructor for term uadd_sat.
pub fn constructor_uadd_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::UaddSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 529.
    return v6;
}

// Generated as internal constructor for term sadd_sat.
pub fn constructor_sadd_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::SaddSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 538.
    return v6;
}

// Generated as internal constructor for term usub_sat.
pub fn constructor_usub_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::UsubSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 547.
    return v6;
}

// Generated as internal constructor for term ssub_sat.
pub fn constructor_ssub_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::SsubSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 556.
    return v6;
}

// Generated as internal constructor for term load.
pub fn constructor_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Load,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 565.
    return v6;
}

// Generated as internal constructor for term store.
pub fn constructor_store<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Value,
    arg4: Offset32,
) -> Value {
    let v6 = &C::value_array_2_ctor(ctx, arg2, arg3);
    let v7 = InstructionData::Store {
        opcode: Opcode::Store,
        args: v6.clone(),
        flags: arg1,
        offset: arg4,
    };
    let v8 = C::make_inst_ctor(ctx, arg0, &v7);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 574.
    return v8;
}

// Generated as internal constructor for term uload8.
pub fn constructor_uload8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 583.
    return v6;
}

// Generated as internal constructor for term sload8.
pub fn constructor_sload8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 592.
    return v6;
}

// Generated as internal constructor for term istore8.
pub fn constructor_istore8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Value,
    arg4: Offset32,
) -> Value {
    let v6 = &C::value_array_2_ctor(ctx, arg2, arg3);
    let v7 = InstructionData::Store {
        opcode: Opcode::Istore8,
        args: v6.clone(),
        flags: arg1,
        offset: arg4,
    };
    let v8 = C::make_inst_ctor(ctx, arg0, &v7);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 601.
    return v8;
}

// Generated as internal constructor for term uload16.
pub fn constructor_uload16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload16,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 610.
    return v6;
}

// Generated as internal constructor for term sload16.
pub fn constructor_sload16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload16,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 619.
    return v6;
}

// Generated as internal constructor for term istore16.
pub fn constructor_istore16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Value,
    arg4: Offset32,
) -> Value {
    let v6 = &C::value_array_2_ctor(ctx, arg2, arg3);
    let v7 = InstructionData::Store {
        opcode: Opcode::Istore16,
        args: v6.clone(),
        flags: arg1,
        offset: arg4,
    };
    let v8 = C::make_inst_ctor(ctx, arg0, &v7);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 628.
    return v8;
}

// Generated as internal constructor for term uload32.
pub fn constructor_uload32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload32,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 637.
    return v6;
}

// Generated as internal constructor for term sload32.
pub fn constructor_sload32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload32,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 646.
    return v6;
}

// Generated as internal constructor for term istore32.
pub fn constructor_istore32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Value,
    arg4: Offset32,
) -> Value {
    let v6 = &C::value_array_2_ctor(ctx, arg2, arg3);
    let v7 = InstructionData::Store {
        opcode: Opcode::Istore32,
        args: v6.clone(),
        flags: arg1,
        offset: arg4,
    };
    let v8 = C::make_inst_ctor(ctx, arg0, &v7);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 655.
    return v8;
}

// Generated as internal constructor for term uload8x8.
pub fn constructor_uload8x8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload8x8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 664.
    return v6;
}

// Generated as internal constructor for term sload8x8.
pub fn constructor_sload8x8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload8x8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 673.
    return v6;
}

// Generated as internal constructor for term uload16x4.
pub fn constructor_uload16x4<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload16x4,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 682.
    return v6;
}

// Generated as internal constructor for term sload16x4.
pub fn constructor_sload16x4<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload16x4,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 691.
    return v6;
}

// Generated as internal constructor for term uload32x2.
pub fn constructor_uload32x2<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload32x2,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 700.
    return v6;
}

// Generated as internal constructor for term sload32x2.
pub fn constructor_sload32x2<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload32x2,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 709.
    return v6;
}

// Generated as internal constructor for term stack_load.
pub fn constructor_stack_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: StackSlot,
    arg2: Offset32,
) -> Value {
    let v4 = InstructionData::StackLoad {
        opcode: Opcode::StackLoad,
        stack_slot: arg1,
        offset: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 718.
    return v5;
}

// Generated as internal constructor for term stack_store.
pub fn constructor_stack_store<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: StackSlot,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::StackStore {
        opcode: Opcode::StackStore,
        arg: arg1,
        stack_slot: arg2,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 727.
    return v6;
}

// Generated as internal constructor for term stack_addr.
pub fn constructor_stack_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: StackSlot,
    arg2: Offset32,
) -> Value {
    let v4 = InstructionData::StackLoad {
        opcode: Opcode::StackAddr,
        stack_slot: arg1,
        offset: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 736.
    return v5;
}

// Generated as internal constructor for term dynamic_stack_load.
pub fn constructor_dynamic_stack_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: DynamicStackSlot,
) -> Value {
    let v3 = InstructionData::DynamicStackLoad {
        opcode: Opcode::DynamicStackLoad,
        dynamic_stack_slot: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 745.
    return v4;
}

// Generated as internal constructor for term dynamic_stack_store.
pub fn constructor_dynamic_stack_store<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: DynamicStackSlot,
) -> Value {
    let v4 = InstructionData::DynamicStackStore {
        opcode: Opcode::DynamicStackStore,
        arg: arg1,
        dynamic_stack_slot: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 754.
    return v5;
}

// Generated as internal constructor for term dynamic_stack_addr.
pub fn constructor_dynamic_stack_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: DynamicStackSlot,
) -> Value {
    let v3 = InstructionData::DynamicStackLoad {
        opcode: Opcode::DynamicStackAddr,
        dynamic_stack_slot: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 763.
    return v4;
}

// Generated as internal constructor for term global_value.
pub fn constructor_global_value<C: Context>(ctx: &mut C, arg0: Type, arg1: GlobalValue) -> Value {
    let v3 = InstructionData::UnaryGlobalValue {
        opcode: Opcode::GlobalValue,
        global_value: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 772.
    return v4;
}

// Generated as internal constructor for term symbol_value.
pub fn constructor_symbol_value<C: Context>(ctx: &mut C, arg0: Type, arg1: GlobalValue) -> Value {
    let v3 = InstructionData::UnaryGlobalValue {
        opcode: Opcode::SymbolValue,
        global_value: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 781.
    return v4;
}

// Generated as internal constructor for term tls_value.
pub fn constructor_tls_value<C: Context>(ctx: &mut C, arg0: Type, arg1: GlobalValue) -> Value {
    let v3 = InstructionData::UnaryGlobalValue {
        opcode: Opcode::TlsValue,
        global_value: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 790.
    return v4;
}

// Generated as internal constructor for term get_pinned_reg.
pub fn constructor_get_pinned_reg<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetPinnedReg,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 799.
    return v3;
}

// Generated as internal constructor for term set_pinned_reg.
pub fn constructor_set_pinned_reg<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::SetPinnedReg,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 808.
    return v4;
}

// Generated as internal constructor for term get_frame_pointer.
pub fn constructor_get_frame_pointer<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetFramePointer,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 817.
    return v3;
}

// Generated as internal constructor for term get_stack_pointer.
pub fn constructor_get_stack_pointer<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetStackPointer,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 826.
    return v3;
}

// Generated as internal constructor for term get_return_address.
pub fn constructor_get_return_address<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetReturnAddress,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 835.
    return v3;
}

// Generated as internal constructor for term table_addr.
pub fn constructor_table_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Table,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::TableAddr {
        opcode: Opcode::TableAddr,
        arg: arg2,
        table: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 844.
    return v6;
}

// Generated as internal constructor for term iconst.
pub fn constructor_iconst<C: Context>(ctx: &mut C, arg0: Type, arg1: Imm64) -> Value {
    let v3 = InstructionData::UnaryImm {
        opcode: Opcode::Iconst,
        imm: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 853.
    return v4;
}

// Generated as internal constructor for term f32const.
pub fn constructor_f32const<C: Context>(ctx: &mut C, arg0: Type, arg1: Ieee32) -> Value {
    let v3 = InstructionData::UnaryIeee32 {
        opcode: Opcode::F32const,
        imm: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 862.
    return v4;
}

// Generated as internal constructor for term f64const.
pub fn constructor_f64const<C: Context>(ctx: &mut C, arg0: Type, arg1: Ieee64) -> Value {
    let v3 = InstructionData::UnaryIeee64 {
        opcode: Opcode::F64const,
        imm: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 871.
    return v4;
}

// Generated as internal constructor for term vconst.
pub fn constructor_vconst<C: Context>(ctx: &mut C, arg0: Type, arg1: Constant) -> Value {
    let v3 = InstructionData::UnaryConst {
        opcode: Opcode::Vconst,
        constant_handle: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 880.
    return v4;
}

// Generated as internal constructor for term shuffle.
pub fn constructor_shuffle<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Immediate,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v6 = InstructionData::Shuffle {
        opcode: Opcode::Shuffle,
        args: v5.clone(),
        imm: arg3,
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 889.
    return v7;
}

// Generated as internal constructor for term null.
pub fn constructor_null<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::Null,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 898.
    return v3;
}

// Generated as internal constructor for term nop.
pub fn constructor_nop<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::Nop,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 907.
    return v3;
}

// Generated as internal constructor for term select.
pub fn constructor_select<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::Select,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 916.
    return v7;
}

// Generated as internal constructor for term select_spectre_guard.
pub fn constructor_select_spectre_guard<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::SelectSpectreGuard,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 925.
    return v7;
}

// Generated as internal constructor for term bitselect.
pub fn constructor_bitselect<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::Bitselect,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 934.
    return v7;
}

// Generated as internal constructor for term vselect.
pub fn constructor_vselect<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::Vselect,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 943.
    return v7;
}

// Generated as internal constructor for term vany_true.
pub fn constructor_vany_true<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::VanyTrue,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 952.
    return v4;
}

// Generated as internal constructor for term vall_true.
pub fn constructor_vall_true<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::VallTrue,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 961.
    return v4;
}

// Generated as internal constructor for term vhigh_bits.
pub fn constructor_vhigh_bits<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::VhighBits,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 970.
    return v4;
}

// Generated as internal constructor for term icmp.
pub fn constructor_icmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntCC,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg2, arg3);
    let v6 = InstructionData::IntCompare {
        opcode: Opcode::Icmp,
        args: v5.clone(),
        cond: arg1.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 979.
    return v7;
}

// Generated as internal constructor for term icmp_imm.
pub fn constructor_icmp_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntCC,
    arg2: Value,
    arg3: Imm64,
) -> Value {
    let v5 = InstructionData::IntCompareImm {
        opcode: Opcode::IcmpImm,
        arg: arg2,
        cond: arg1.clone(),
        imm: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 988.
    return v6;
}

// Generated as internal constructor for term iadd.
pub fn constructor_iadd<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Iadd,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 997.
    return v6;
}

// Generated as internal constructor for term isub.
pub fn constructor_isub<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Isub,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1006.
    return v6;
}

// Generated as internal constructor for term ineg.
pub fn constructor_ineg<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ineg,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1015.
    return v4;
}

// Generated as internal constructor for term iabs.
pub fn constructor_iabs<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Iabs,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1024.
    return v4;
}

// Generated as internal constructor for term imul.
pub fn constructor_imul<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Imul,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1033.
    return v6;
}

// Generated as internal constructor for term umulhi.
pub fn constructor_umulhi<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Umulhi,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1042.
    return v6;
}

// Generated as internal constructor for term smulhi.
pub fn constructor_smulhi<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Smulhi,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1051.
    return v6;
}

// Generated as internal constructor for term sqmul_round_sat.
pub fn constructor_sqmul_round_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::SqmulRoundSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1060.
    return v6;
}

// Generated as internal constructor for term udiv.
pub fn constructor_udiv<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Udiv,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1069.
    return v6;
}

// Generated as internal constructor for term sdiv.
pub fn constructor_sdiv<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Sdiv,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1078.
    return v6;
}

// Generated as internal constructor for term urem.
pub fn constructor_urem<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Urem,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1087.
    return v6;
}

// Generated as internal constructor for term srem.
pub fn constructor_srem<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Srem,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1096.
    return v6;
}

// Generated as internal constructor for term iadd_imm.
pub fn constructor_iadd_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::IaddImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1105.
    return v5;
}

// Generated as internal constructor for term imul_imm.
pub fn constructor_imul_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::ImulImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1114.
    return v5;
}

// Generated as internal constructor for term udiv_imm.
pub fn constructor_udiv_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::UdivImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1123.
    return v5;
}

// Generated as internal constructor for term sdiv_imm.
pub fn constructor_sdiv_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::SdivImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1132.
    return v5;
}

// Generated as internal constructor for term urem_imm.
pub fn constructor_urem_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::UremImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1141.
    return v5;
}

// Generated as internal constructor for term srem_imm.
pub fn constructor_srem_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::SremImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1150.
    return v5;
}

// Generated as internal constructor for term irsub_imm.
pub fn constructor_irsub_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::IrsubImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1159.
    return v5;
}

// Generated as internal constructor for term iadd_cin.
pub fn constructor_iadd_cin<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::IaddCin,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1168.
    return v7;
}

// Generated as internal constructor for term iadd_cout.
pub fn constructor_iadd_cout<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::IaddCout,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1177.
    return v6;
}

// Generated as internal constructor for term iadd_carry.
pub fn constructor_iadd_carry<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::IaddCarry,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1186.
    return v7;
}

// Generated as internal constructor for term uadd_overflow_trap.
pub fn constructor_uadd_overflow_trap<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: &TrapCode,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v6 = InstructionData::IntAddTrap {
        opcode: Opcode::UaddOverflowTrap,
        args: v5.clone(),
        code: arg3.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1195.
    return v7;
}

// Generated as internal constructor for term isub_bin.
pub fn constructor_isub_bin<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::IsubBin,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1204.
    return v7;
}

// Generated as internal constructor for term isub_bout.
pub fn constructor_isub_bout<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::IsubBout,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1213.
    return v6;
}

// Generated as internal constructor for term isub_borrow.
pub fn constructor_isub_borrow<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::IsubBorrow,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1222.
    return v7;
}

// Generated as internal constructor for term band.
pub fn constructor_band<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Band,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1231.
    return v6;
}

// Generated as internal constructor for term bor.
pub fn constructor_bor<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Bor,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1240.
    return v6;
}

// Generated as internal constructor for term bxor.
pub fn constructor_bxor<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Bxor,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1249.
    return v6;
}

// Generated as internal constructor for term bnot.
pub fn constructor_bnot<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bnot,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1258.
    return v4;
}

// Generated as internal constructor for term band_not.
pub fn constructor_band_not<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::BandNot,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1267.
    return v6;
}

// Generated as internal constructor for term bor_not.
pub fn constructor_bor_not<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::BorNot,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1276.
    return v6;
}

// Generated as internal constructor for term bxor_not.
pub fn constructor_bxor_not<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::BxorNot,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1285.
    return v6;
}

// Generated as internal constructor for term band_imm.
pub fn constructor_band_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::BandImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1294.
    return v5;
}

// Generated as internal constructor for term bor_imm.
pub fn constructor_bor_imm<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Imm64) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::BorImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1303.
    return v5;
}

// Generated as internal constructor for term bxor_imm.
pub fn constructor_bxor_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::BxorImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1312.
    return v5;
}

// Generated as internal constructor for term rotl.
pub fn constructor_rotl<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Rotl,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1321.
    return v6;
}

// Generated as internal constructor for term rotr.
pub fn constructor_rotr<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Rotr,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1330.
    return v6;
}

// Generated as internal constructor for term rotl_imm.
pub fn constructor_rotl_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::RotlImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1339.
    return v5;
}

// Generated as internal constructor for term rotr_imm.
pub fn constructor_rotr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::RotrImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1348.
    return v5;
}

// Generated as internal constructor for term ishl.
pub fn constructor_ishl<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Ishl,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1357.
    return v6;
}

// Generated as internal constructor for term ushr.
pub fn constructor_ushr<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Ushr,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1366.
    return v6;
}

// Generated as internal constructor for term sshr.
pub fn constructor_sshr<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Sshr,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1375.
    return v6;
}

// Generated as internal constructor for term ishl_imm.
pub fn constructor_ishl_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::IshlImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1384.
    return v5;
}

// Generated as internal constructor for term ushr_imm.
pub fn constructor_ushr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::UshrImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1393.
    return v5;
}

// Generated as internal constructor for term sshr_imm.
pub fn constructor_sshr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::SshrImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1402.
    return v5;
}

// Generated as internal constructor for term bitrev.
pub fn constructor_bitrev<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bitrev,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1411.
    return v4;
}

// Generated as internal constructor for term clz.
pub fn constructor_clz<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Clz,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1420.
    return v4;
}

// Generated as internal constructor for term cls.
pub fn constructor_cls<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Cls,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1429.
    return v4;
}

// Generated as internal constructor for term ctz.
pub fn constructor_ctz<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ctz,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1438.
    return v4;
}

// Generated as internal constructor for term bswap.
pub fn constructor_bswap<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bswap,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1447.
    return v4;
}

// Generated as internal constructor for term popcnt.
pub fn constructor_popcnt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Popcnt,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1456.
    return v4;
}

// Generated as internal constructor for term fcmp.
pub fn constructor_fcmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &FloatCC,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg2, arg3);
    let v6 = InstructionData::FloatCompare {
        opcode: Opcode::Fcmp,
        args: v5.clone(),
        cond: arg1.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1465.
    return v7;
}

// Generated as internal constructor for term fadd.
pub fn constructor_fadd<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fadd,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1474.
    return v6;
}

// Generated as internal constructor for term fsub.
pub fn constructor_fsub<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fsub,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1483.
    return v6;
}

// Generated as internal constructor for term fmul.
pub fn constructor_fmul<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fmul,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1492.
    return v6;
}

// Generated as internal constructor for term fdiv.
pub fn constructor_fdiv<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fdiv,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1501.
    return v6;
}

// Generated as internal constructor for term sqrt.
pub fn constructor_sqrt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Sqrt,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1510.
    return v4;
}

// Generated as internal constructor for term fma.
pub fn constructor_fma<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::Fma,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1519.
    return v7;
}

// Generated as internal constructor for term fneg.
pub fn constructor_fneg<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fneg,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1528.
    return v4;
}

// Generated as internal constructor for term fabs.
pub fn constructor_fabs<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fabs,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1537.
    return v4;
}

// Generated as internal constructor for term fcopysign.
pub fn constructor_fcopysign<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fcopysign,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1546.
    return v6;
}

// Generated as internal constructor for term fmin.
pub fn constructor_fmin<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fmin,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1555.
    return v6;
}

// Generated as internal constructor for term fmin_pseudo.
pub fn constructor_fmin_pseudo<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::FminPseudo,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1564.
    return v6;
}

// Generated as internal constructor for term fmax.
pub fn constructor_fmax<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fmax,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1573.
    return v6;
}

// Generated as internal constructor for term fmax_pseudo.
pub fn constructor_fmax_pseudo<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::FmaxPseudo,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1582.
    return v6;
}

// Generated as internal constructor for term ceil.
pub fn constructor_ceil<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ceil,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1591.
    return v4;
}

// Generated as internal constructor for term floor.
pub fn constructor_floor<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Floor,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1600.
    return v4;
}

// Generated as internal constructor for term trunc.
pub fn constructor_trunc<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Trunc,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1609.
    return v4;
}

// Generated as internal constructor for term nearest.
pub fn constructor_nearest<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Nearest,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1618.
    return v4;
}

// Generated as internal constructor for term is_null.
pub fn constructor_is_null<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::IsNull,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1627.
    return v4;
}

// Generated as internal constructor for term is_invalid.
pub fn constructor_is_invalid<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::IsInvalid,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1636.
    return v4;
}

// Generated as internal constructor for term bitcast.
pub fn constructor_bitcast<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
) -> Value {
    let v4 = InstructionData::LoadNoOffset {
        opcode: Opcode::Bitcast,
        arg: arg2,
        flags: arg1,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1645.
    return v5;
}

// Generated as internal constructor for term scalar_to_vector.
pub fn constructor_scalar_to_vector<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::ScalarToVector,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1654.
    return v4;
}

// Generated as internal constructor for term bmask.
pub fn constructor_bmask<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bmask,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1663.
    return v4;
}

// Generated as internal constructor for term ireduce.
pub fn constructor_ireduce<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ireduce,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1672.
    return v4;
}

// Generated as internal constructor for term snarrow.
pub fn constructor_snarrow<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Snarrow,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1681.
    return v6;
}

// Generated as internal constructor for term unarrow.
pub fn constructor_unarrow<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Unarrow,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1690.
    return v6;
}

// Generated as internal constructor for term uunarrow.
pub fn constructor_uunarrow<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Uunarrow,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1699.
    return v6;
}

// Generated as internal constructor for term swiden_low.
pub fn constructor_swiden_low<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::SwidenLow,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1708.
    return v4;
}

// Generated as internal constructor for term swiden_high.
pub fn constructor_swiden_high<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::SwidenHigh,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1717.
    return v4;
}

// Generated as internal constructor for term uwiden_low.
pub fn constructor_uwiden_low<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::UwidenLow,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1726.
    return v4;
}

// Generated as internal constructor for term uwiden_high.
pub fn constructor_uwiden_high<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::UwidenHigh,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1735.
    return v4;
}

// Generated as internal constructor for term iadd_pairwise.
pub fn constructor_iadd_pairwise<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::IaddPairwise,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1744.
    return v6;
}

// Generated as internal constructor for term widening_pairwise_dot_product_s.
pub fn constructor_widening_pairwise_dot_product_s<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::WideningPairwiseDotProductS,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1753.
    return v6;
}

// Generated as internal constructor for term uextend.
pub fn constructor_uextend<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Uextend,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1762.
    return v4;
}

// Generated as internal constructor for term sextend.
pub fn constructor_sextend<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Sextend,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1771.
    return v4;
}

// Generated as internal constructor for term fpromote.
pub fn constructor_fpromote<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fpromote,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1780.
    return v4;
}

// Generated as internal constructor for term fdemote.
pub fn constructor_fdemote<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fdemote,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1789.
    return v4;
}

// Generated as internal constructor for term fvdemote.
pub fn constructor_fvdemote<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fvdemote,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1798.
    return v4;
}

// Generated as internal constructor for term fvpromote_low.
pub fn constructor_fvpromote_low<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FvpromoteLow,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1807.
    return v4;
}

// Generated as internal constructor for term fcvt_to_uint.
pub fn constructor_fcvt_to_uint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToUint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1816.
    return v4;
}

// Generated as internal constructor for term fcvt_to_sint.
pub fn constructor_fcvt_to_sint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToSint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1825.
    return v4;
}

// Generated as internal constructor for term fcvt_to_uint_sat.
pub fn constructor_fcvt_to_uint_sat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToUintSat,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1834.
    return v4;
}

// Generated as internal constructor for term fcvt_to_sint_sat.
pub fn constructor_fcvt_to_sint_sat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToSintSat,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1843.
    return v4;
}

// Generated as internal constructor for term fcvt_from_uint.
pub fn constructor_fcvt_from_uint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtFromUint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1852.
    return v4;
}

// Generated as internal constructor for term fcvt_from_sint.
pub fn constructor_fcvt_from_sint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtFromSint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1861.
    return v4;
}

// Generated as internal constructor for term fcvt_low_from_sint.
pub fn constructor_fcvt_low_from_sint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtLowFromSint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1870.
    return v4;
}

// Generated as internal constructor for term isplit.
pub fn constructor_isplit<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Isplit,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1879.
    return v4;
}

// Generated as internal constructor for term iconcat.
pub fn constructor_iconcat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Iconcat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1888.
    return v6;
}

// Generated as internal constructor for term atomic_rmw.
pub fn constructor_atomic_rmw<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: &AtomicRmwOp,
    arg3: Value,
    arg4: Value,
) -> Value {
    let v6 = &C::value_array_2_ctor(ctx, arg3, arg4);
    let v7 = InstructionData::AtomicRmw {
        opcode: Opcode::AtomicRmw,
        args: v6.clone(),
        flags: arg1,
        op: arg2.clone(),
    };
    let v8 = C::make_inst_ctor(ctx, arg0, &v7);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1897.
    return v8;
}

// Generated as internal constructor for term atomic_cas.
pub fn constructor_atomic_cas<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Value,
    arg4: Value,
) -> Value {
    let v6 = &C::value_array_3_ctor(ctx, arg2, arg3, arg4);
    let v7 = InstructionData::AtomicCas {
        opcode: Opcode::AtomicCas,
        args: v6.clone(),
        flags: arg1,
    };
    let v8 = C::make_inst_ctor(ctx, arg0, &v7);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1906.
    return v8;
}

// Generated as internal constructor for term atomic_load.
pub fn constructor_atomic_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
) -> Value {
    let v4 = InstructionData::LoadNoOffset {
        opcode: Opcode::AtomicLoad,
        arg: arg2,
        flags: arg1,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1915.
    return v5;
}

// Generated as internal constructor for term atomic_store.
pub fn constructor_atomic_store<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg2, arg3);
    let v6 = InstructionData::StoreNoOffset {
        opcode: Opcode::AtomicStore,
        args: v5.clone(),
        flags: arg1,
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1924.
    return v7;
}

// Generated as internal constructor for term fence.
pub fn constructor_fence<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::Fence,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1933.
    return v3;
}

// Generated as internal constructor for term extract_vector.
pub fn constructor_extract_vector<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Uimm8,
) -> Value {
    let v4 = InstructionData::BinaryImm8 {
        opcode: Opcode::ExtractVector,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/rajeeb/Work/personal/fluence-fil-bangalore/target/debug/build/cranelift-codegen-d602c9be4ae391d2/out/clif_opt.isle line 1942.
    return v5;
}
